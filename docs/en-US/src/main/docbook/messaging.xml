<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="messaging">
  <title>Messaging</title>

  <section>
    <title>Introduction</title>

    <formalpara>
      <title>HornetQ</title>

      <para>TorqueBox integrates the JBoss HornetQ message broker technology.
      It is automatically available to you, with no additional configuration
      required to start the messaging service. HornetQ supports clustered
      messaging, to allow for load-balancing, failover, and other advanced
      deployments.</para>
    </formalpara>

    <para>The term "messaging" encompasses a large area of functionality.
    Messaging solutions are used to achieve loosely-coupled, asynchronous
    systems. The primary actors in a messaging-based system are messages,
    destinations, consumers, and producers. From an implementation
    perspective, a broker mediates the relationships between the other
    actors.</para>

    <mediaobject>
      <imageobject role="html">
        <imagedata align="center" contentwidth="4in"
                   fileref="images/messaging-overview.png" format="PNG" />
      </imageobject>

      <imageobject role="fo">
        <imagedata align="center" contentwidth="4in"
                   fileref="images/messaging-overview.svg" format="SVG" />
      </imageobject>
    </mediaobject>

    <formalpara>
      <title>Messages</title>

      <para>The unit of communication within a messaging system is a message.
      A message may either be simply a blob of octets, or it might have some
      higher-order, application-defined semantics. All messages include a set
      of headers, similar to email.</para>
    </formalpara>

    <formalpara>
      <title>Destinations</title>

      <para>A destination represents a rendezvous where messages are
      exchanged. A message message may be sent to a destination by one actor,
      and received from the destination by another.</para>
    </formalpara>

    <para>There are two main types of destinations:
    <emphasis>queues</emphasis> and <emphasis>topics</emphasis>. All
    destinations allow multiple actors to place messages with them. The type
    of destination affects what happens to the message once given to the
    destination. A queue delivers to the message to a single recipient
    (possibly one of many candidate recipients). A topic delivers the message
    to multiple interested recipients.</para>

    <para>In the image below, the green lines represent the flow of a single
    message from a producer to one-or-more consumers through a topic and a
    queue.</para>

    <mediaobject>
      <imageobject role="html">
        <imagedata align="center" contentwidth="4in"
                   fileref="images/messaging-queues-vs-topics.png"
                   format="PNG" />
      </imageobject>

      <imageobject role="fo">
        <imagedata align="center" contentwidth="4in"
                   fileref="images/messaging-queues-vs-topics.svg"
                   format="SVG" />
      </imageobject>
    </mediaobject>

    <formalpara>
      <title>Producers</title>

      <para>Any component or client code that creates messages and gives them
      to the message broker for delivery is considered a
      <glossterm>producer</glossterm>. Generally speaking, the producer does
      not know the details of the destination.</para>
    </formalpara>

    <formalpara>
      <title>Consumers</title>

      <para>Any component that waits for messages to be delivered to it by the
      message broker is consider a <glossterm>consumer</glossterm>. A consumer
      is unaware of the producer and any other consumers, potentially.</para>
    </formalpara>
  </section>

  <section>
    <title>Deploying Destinations</title>

    <para>Queues and topics (collectively known as destinations) may be
    deployed with with your application, or separate from your application.
    Additionally, various parts of your application may also implicitly deploy
    and use some destinations.</para>

    <para>Each method has advantages and disadvantages involving the
    expectations of your application and its interaction with resources
    outside the scope of the application.</para>

    <section>
      <title>Deployment Styles</title>

      <section>
        <title>Deploying destinations with your application</title>

        <para>If you decide to deploy your queues and topics with your
        application, you automatically align their lifecycle to the deployment
        cycle of your application. If you undeploy your application, your
        queues and topics will also disappear, and be unable to receive
        messages. If the queues are used only internally to your application,
        and short lifespan semantics are useful to you, deploying destinations
        with your application reduces deployment steps and moving
        parts.</para>
      </section>

      <section>
        <title>Deploying destinations apart from your application</title>

        <para>If you deploy destinations separate and apart from your
        application, they become long-lived first-class component citizens in
        your environment. Applications may be deployed and undeployed, while
        the destinations continue to function, accepting and processing
        messages to the best of their ability.</para>

        <para>If the consumers to a destination are offline, the destination
        may persist and store any unhandled messages until a consumer
        re-attaches.</para>

        <para>The downside is that by making destinations first-class
        top-level components of your environment, you must also manage, deploy
        and undeploy them separate from any app, creating additional
        work.</para>
      </section>
    </section>

    <section>
      <title>Deployment Descriptors</title>

      <para>You have several options when deploying queues and topics, based
      on the lifecycle that suits your systems best.</para>

      <section>
        <title><filename>Long-lived queues and topics</filename></title>

        <para>If your queues and topics have a lifecycle that extends beyond
        the deployment of any single app, you may want long-lived queues and
        topics. Long-lived destinations are first-order components, and may be
        deployed on their own. In this way, many applications can come and go
        over time, publishing and consuming from the same queues. </para>

        <para>When using long-lived destinations, the corresponding deployment
        descriptors are placed directly into the <filename>deploy/</filename>
        directory of the TorqueBox AS configuration you are using.</para>

        <formalpara>
          <title>Queues</title>

          <para>To deploy queues, a simple YAML file is required,
          simply naming the queue, and providing additional
          configuration parameters.  Currently, no additional
          configuration parameters are allowed. FIXME: Is this true?
          Don't we allow the durable parameter?</para>
        </formalpara>

        <para><example>
            <title>queues.yml</title>

            <para><programlisting>/queues/my_queue:

/queues/my_other_queue:

</programlisting>The name of the queue will be used when registering the queue
            in the naming-service, and is used to discover the queue for
            attaching consumers and producers.</para>

            <para>By convention, queues are named with the prefix of
            <filename>/queues</filename>.</para>
          </example></para>

        <formalpara>
          <title>Topics</title>

          <para>To deploy topics, a simple YAML file is required, simply
          naming the topic, and providing additional configuration parameters.
          Currently, no additional configuration parameters are
          allowed.</para>
        </formalpara>

        <para><example>
            <title>topics.yml</title>

            <para><programlisting>/topics/my_topic:

/topics/my_other_topic:

</programlisting>The name of the queue will be used when registering the topic
            in the naming-service, and is used to discover the topic for
            attaching consumers and producers.</para>

            <para>By convention, topics are named with the prefix of
            <filename>/topics</filename>.</para>
          </example></para>
      </section>

      <section>
        <title>Application-linked queues and topics</title>

        <para>Some destinations are intimately tied to the lifecycle of some
        particular application. For example, internally in the asynchornous
        tasks implementation, an application-link queue is used. </para>

        <para>Destinations deployed with your application also undeploy when
        your application is undeployed. These destinations are configuration
        through either your application's internal
        <filename>torquebox.yml</filename> descriptor, or through an external
        <filename><replaceable>*</replaceable>-knob.yml</filename>
        descriptor.</para>

        <para>Within either of these files, you may use a
        <parameter>queues:</parameter> section to define queues and a
        <parameter>topics:</parameter> section to define topics. </para>

        <para><example>
            <title>Defining topics and queues in
            <filename>torquebox.yml</filename></title>

            <para><screen>application:
  ..
queues:
  /queues/my_app_queue:

topics:
  /queues/my_app_topic:</screen></para>
          </example></para>
      </section>
    </section>
  </section>

  <section>
    <title>TorqueBox Ruby Classes</title>

    <para>All classes in the <classname>TorqueBox::Messaging</classname>
    module reside in the Ruby gem,
    <filename>torquebox-messaging</filename>, so to use
    them in your Rails app, add this to your
    <filename>config/environment.rb</filename>:</para>

    <example>
      <title>To use <classname>TorqueBox::Messaging</classname> in a Rails
      app</title>

      <para><programlisting>Rails::Initializer.run do |config|
  ...
  config.gem 'torquebox-messaging'
  ...</programlisting></para>
    </example>

    <para>And to use them in any other JRuby script, it's even simpler.
    First, ensure that <filename>rubygems</filename> is loaded, then
    require the <filename>torquebox-messaging</filename> feature.
    </para>

    <example>
      <title>To use <classname>TorqueBox::Messaging</classname> in a shell
      script</title>

      <para><programlisting>#!/usr/bin/env jruby

require 'rubygems'
require 'torquebox-messaging'
        </programlisting></para>
    </example>
  </section>

  <section>
    <title>Messaging Abstractions</title>

    <section>
      <title>Queues and Topics</title>

      <para>There are two main messaging destination abstractions:
      <classname>TorqueBox::Messaging::Queue</classname> and
      <classname>TorqueBox::Messaging::Topic</classname>. Each has a
      <methodname>publish</methodname> and a
      <methodname>receive</methodname> method, and each must be
      constructed with a <parameter>name</parameter> and an optional
      hash of options, the keys of which are as follows:</para>

      <table>
        <title>Message destination options</title>

        <tgroup cols="3">
          <colspec align="left" />

          <thead>
            <row>
              <entry>Option</entry>

              <entry>Default</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><parameter>:naming_host</parameter></entry>

              <entry>localhost</entry>

              <entry>Should be the hostname or ip address of the JNDI
              naming server containing the destination names.</entry>
            </row>

            <row>
              <entry><parameter>:naming_port</parameter></entry>

              <entry>1099</entry>

              <entry>The port of the JNDI naming server.</entry>
            </row>

            <row>
              <entry><parameter>:ack_mode</parameter></entry>

              <entry><varname>:auto</varname></entry>

              <entry>Corresponds to one of the three
              <classname>javax.jms.Session</classname> modes for
              message delivery acknowledgement:
              <varname>:auto</varname>, <varname>:client</varname> and
              <varname>:dups_ok</varname>.</entry>
            </row>

            <row>
              <entry><parameter>:transacted</parameter></entry>

              <entry>true</entry>

              <entry>Indicates whether the underlying session is in
              <emphasis>transacted</emphasis> mode.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Though sometimes convenient, these methods are fairly
      low-level and higher-level abstractions such as <link
      linkend="consumers">MessageProcessors</link>, <link
      linkend="async-tasks">Tasks</link>, and <link
      linkend="backgroundable">Backgroundable</link> are often
      better-suited to the task.</para>

      <section id="producers">
        <title>Publishing Messages</title>

        <para>It's trivial to publish a message to a JMS
        <classname>Queue</classname> or <classname>Topic</classname>
        with TorqueBox. And if all of your message consumers are Ruby
        clients, the contents of the messages can be any serializable
        Ruby or Java object. You just need to ensure that the type of
        content you produce resides in the runtime environments of
        both the producer and the consumer.</para>

        <para>To send a message, simply construct either a
        <classname>Topic</classname> or a <classname>Queue</classname>
        instance with its name, and then call its publish method. The
        API's of both Topics and Queues are identical; they each
        simply represent a destination for your messages.</para>

        <example>
          <title>Publish text messages</title>

          <para><programlisting>queue = TorqueBox::Messaging::Queue.new('/queues/foo')
queue.publish "A text message"

topic = TorqueBox::Messaging::Topic.new('/topics/foo')
topic.publish "A text message"
          </programlisting></para>
        </example>

        <example>
          <title>Publish a Ruby Hash</title>

          <para><programlisting>queue = TorqueBox::Messaging::Queue.new('/queues/foo')
queue.publish {:key =&gt; 'value', :list =&gt; %w{one two three}}
          </programlisting></para>

          <para>This is enormously convenient, as any serializable
          object is permitted, but it only makes sense if your queue
          consumers are also written in Ruby.</para>
        </example>

        <example>
          <title>Send message using a remote JNDI server</title>

          <para><programlisting>queue = TorqueBox::Messaging::Queue.new('/queues/foo', :naming_host =&gt; 'jndi.jboss.org',
                                        :naming_port =&gt; 1099)
queue.publish "Some message"</programlisting></para>
        </example>

        <para>The <methodname>publish</methodname> method takes an
        optional second argument containing a hash of options, the
        keys of which are as follows:</para>

        <table>
          <title>Publish options</title>

          <tgroup cols="3">
            <colspec align="left" />
            <thead>
              <row>
                <entry>Option</entry>
                <entry>Default</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><parameter>:priority</parameter></entry>
                
                <entry>:normal</entry>
                
                <entry>higher priority messages will be delivered before lower priority
                messages within the context of a queue. You can specify the priority as
                an integer in the range 0..9, or as one of the following convenience
                symbols (with the corresponding integer priorities in parentheses):
                <itemizedlist>
                  <listitem><para><parameter>:low</parameter> (1)</para></listitem>
                  <listitem><para><parameter>:normal</parameter> (4)</para></listitem>
                  <listitem><para><parameter>:high</parameter> (7)</para></listitem>
                  <listitem><para><parameter>:critical</parameter> (9)</para></listitem>
                </itemizedlist>
                Higher priority messages will be processed before lower priority ones
                for a specific message processor.</entry>
              </row>

              <row>
                <entry><parameter>:ttl</parameter></entry>

                <entry></entry>

                <entry>The maximum time the message will wait in a
                destination to be consumed, in milliseconds. If the
                message isn't consumed within this time it will be
                delivered to an expiry queue. By default, messages don't have a
                ttl (and therefore never expire). By default, expired messages 
                end up on the <varname>/queue/ExpiryQueue</varname> queue. If
                you want to do something special with those messages, you'll need 
                to add a processor for that queue.</entry>
              </row>

              <row>
                <entry><parameter>:persistent</parameter></entry>
                
                <entry>true</entry>
                
                <entry>By default, queued messages will survive across AS restarts.
                If you don't want a message to be persistent, set the persistence to
                <parameter>false</parameter>.</entry>
              </row>

              <row>
                <entry><parameter>:correlation_id</parameter></entry>
                <entry>nil</entry>
                <entry>The string value to set for the <ulink
                url="http://download.oracle.com/javaee/1.3/api/javax/jms/Message.html#setJMSCorrelationID%28java.lang.String%29">JMSCorrelationID</ulink>
                message header.</entry>
              </row>
              <row>
                <entry><parameter>:reply_to</parameter></entry>
                <entry>nil</entry>
                <entry>The
                <classname>javax.jms.Destination</classname> value to
                set for the <ulink
                url="http://download.oracle.com/javaee/1.3/api/javax/jms/Message.html#setJMSReplyTo%28javax.jms.Destination%29">JMSReplyTo</ulink>
                message header.</entry>
              </row>
              <row>
                <entry><parameter>:type</parameter></entry>
                <entry>nil</entry>
                <entry>The string value to set for the <ulink
                url="http://download.oracle.com/javaee/1.3/api/javax/jms/Message.html#setJMSType%28java.lang.String%29">JMSType</ulink>
                message header.</entry>
              </row>
              <row>
                <entry><parameter>:properties</parameter></entry>
                <entry>nil</entry>
                <entry>A hash of string key/value pairs to set as
                message properties. This can be used as
                application-specific headers and matched against in
                the <varname>:selector</varname> option of the
                <methodname>receive</methodname> method.</entry>
              </row>
              <row>
                <entry><parameter>:startup_timeout</parameter></entry>
                <entry>30000</entry>
                <entry>The maximum time to wait for the destination to
                become ready on initial app startup, in
                milliseconds. On a very slow machine this may need to
                be increased from the default.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title>Receiving Messages</title>

        <para>Receiving messages from a JMS
        <classname>Queue</classname> or <classname>Topic</classname>
        is very similar to publishing messages. To consume a message,
        simply construct either a <classname>Queue</classname> or
        <classname>Topic</classname> instance with its name, and then
        call its receive method. The API's of both Topics and Queues
        are identical.</para>

        <example>
          <title>Receive messages</title>

          <para><programlisting>queue = TorqueBox::Messaging::Queue.new('/queues/foo')
message = queue.receive

topic = TorqueBox::Messaging::Topic.new('/topics/foo')
message = topic.receive
          </programlisting></para>
        </example>

        <para>The <methodname>receive</methodname> takes an optional
        argument containing a hash of options, the keys of which are
        as follows:</para>

        <table>
          <title>Receive options</title>

          <tgroup cols="3">
            <colspec align="left" />
            <thead>
              <row>
                <entry>Option</entry>
                <entry>Default</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><parameter>:decode</parameter></entry>
                <entry>true</entry>
                <entry>When <parameter>:decode</parameter> is set to
                true, <methodname>receive</methodname> returns the
                same value that was sent via
                <methodname>publish</methodname>. If
                <parameter>:decode</parameter> is false, the JMS
                <ulink
                url="http://download.oracle.com/javaee/1.3/api/javax/jms/TextMessage.html">TextMessage</ulink>
                object will be returned instead. This should be true
                unless you need to access headers or properties of the
                JMS message.</entry>
              </row>
              <row>
                <entry><parameter>:timeout</parameter></entry>
                <entry>0</entry>
                <entry>The amount of time to wait before giving up, in
                milliseconds. A value of 0 means to wait
                indefinitely. If <methodname>receive</methodname>
                times out it will return a <literal>nil</literal>
                value.</entry>
              </row>
              <row>
                <entry><parameter>:selector</parameter></entry>
                <entry>nil</entry>
                <entry>The JMS selector string used to filter messages
                received by this consumer. For details see the
                "Message Selectors" section of the <ulink
                url="http://download.oracle.com/javaee/1.3/api/javax/jms/Message.html">javax.jms.Message</ulink>
                documentation. A <literal>nil</literal> value means
                all messages are received.</entry>
              </row>
              <row>
                <entry><parameter>:startup_timeout</parameter></entry>
                <entry>30000</entry>
                <entry>The maximum time to wait for the destination to
                become ready on initial app startup, in
                milliseconds. On a very slow machine this may need to
                be increased from the default.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title>Synchronous Messaging</title>

        <para>The <methodname>publish</methodname> and
        <methodname>receive</methodname> methods and our higher-level
        messaging abstractions are designed for asynchronous
        communication and are recommended for most uses. However, if
        you do need to send a message and wait for a response,
        TorqueBox also provides a synchronous messaging
        abstraction.</para>

        <example>
          <title>Synchronous messaging</title>

          <para><programlisting>queue = TorqueBox::Messaging::Queue.new('/queues/foo')
Thread.new {
  queue.receive_and_publish(:timeout => 5000) { |message| message.upcase }
}
message = queue.publish_and_receive "ping", :timeout => 5000
# message equals "PING"
          </programlisting></para>
        </example>

        <para>You send a message with the
        <methodname>publish_and_receive</methodname> method which
        blocks until the <parameter>:timeout</parameter> elapses or a
        response is received. This method has a default
        <parameter>:timeout</parameter> of 10 seconds since you'll
        rarely want to wait indefinitely for a response. In a separate
        thread (likely TorqueBox Services - <xref linkend="services"
        />), you consume messages and publish responses with the
        <methodname>receive_and_publish</methodname> method. The
        return value of the block passed to this method is the message
        response. The options allowed in both these methods are a
        union of those from <methodname>publish</methodname> and
        <methodname>receive</methodname>. Synchronous messaging is
        only available with queues, not topics.</para>

      </section>
    </section>

    <section id="consumers">
      <title>Message Processors</title>

      <para>Message consumers may be implemented in Ruby and easily
      attached to destinations. A Ruby consumer may either interact at
      the lowest JMS-level, or take advantage of higher-level
      semantics.</para>

      <section>
        <title>Low-level message consumption</title>

        <para>For the lowest-level implementation of a Ruby consumer,
        the class must simply implement
        <function>process!(msg)</function> which receives a
        <classname>javax.jms.Message</classname> as its
        parameter. Admittedly, this gets quite a lot of Java in your
        Ruby, but it's available if needed.</para>

        <para><example>
          <title>Low-level message consumer</title>

          <para><programlisting>class MyLowConsumer
  def process!(msg)
    # manipulate the javax.jms.Message here
  end
end</programlisting></para>
        </example></para>
      </section>

      <section>
        <title>Syntactic sugar for message consumers</title>

        <para>Message consumers may extend
        <classname>TorqueBox::Messaging::MessageProcessor</classname>
        and implement an <function>on_message(body)</function> method
        which will receive the body of the JMS message.</para>

        <para><example>
          <title>MessageProcessor subclass</title>

          <para><programlisting>class MyConsumer &lt; TorqueBox::Messaging::MessageProcessor
  def on_message(body)
    # The body will be of whatever type was <link linkend="producers">published by the Producer</link>
    # the entire JMS message is available as a member variable called <function>message()</function>
  end
end</programlisting></para>

          <para>There is an accessor for the actual JMS message that
          is set by TorqueBox prior to invoking
          <function>on_message</function>, so it's there if you need
          it.</para>
        </example></para>
      </section>

      <section>
        <title>Connecting Consumers to Destinations</title>

        <para>You can connect consumers hosted within a
        TorqueBox-based application, or in external scripts. The
        method for each environment is similar, but slightly
        different, since TorqueBox-hosted consumers get more baked-in
        support from the container.</para>

        <section>
          <title>Connecting consumers within TorqueBox</title>

          <para>To connect consumers within a TorqueBox-deployed
          application, you need to add a messaging: section to your
          <filename><filename>torquebox.yml</filename></filename> (or
          external *-knob.yml descriptor).</para>

          <warning>
            <para>While previous versions of TorqueBox supported a
            messaging.yml file, this usage is now deprecated and will
            be removed before the file release.</para>
          </warning>

          <para>This section will contain the mappings from your
          destinations (topics and queues) to your consumers. The
          section is a YAML hash, the keys of which are your
          destination names, which should correspond to existing
          queues and topics. These destinations may be deployed
          through the same <filename>torquebox.yml</filename> or as
          long-lived destinations.</para>

          <example>
            <title>Messaging handlers in torquebox.yml</title>

            <para><programlisting>application:
  ..
queues:
  /queues/my_app_queue:

messaging:
  /queues/my_app_queue:     MyFooHandler
  /topics/long_lived_topic: MyBazHandler</programlisting></para>

            <para>The classes MyFooHandler and MyBazHandler would
            correspond to files available on the load path:
            <filename>my_foo_handler.rb</filename> and
            <filename>my_baz_handler.rb</filename>, respectively. In a
            Rails app, these files would typically reside beneath
            <filename>lib/</filename> or
            <filename>app/models/</filename>.</para>
          </example>

          <para>The above example shows the simplest possible
          configuration, but it's possible to alter the behavior of
          your message processor using the following options:</para>

          <table>
            <title>Message processor options</title>

            <tgroup cols="3">
              <colspec align="left" />

              <thead>
                <row>
                  <entry>Option</entry>

                  <entry>Default</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><parameter>concurrency</parameter></entry>

                  <entry>1</entry>

                  <entry>May be used to throttle the throughput of
                  your processor. Processors are single-threaded, by
                  default, but you can increase this value to match
                  the number of concurrent messages you expect to
                  receive. Note that this value determines the number
                  of consumers connected to the destination and thus
                  you'll rarely want a concurrency greater than 1 for
                  topics since that means you'll process duplicate
                  messages.</entry>
                </row>

                <row>
                  <entry><parameter>filter</parameter></entry>

                  <entry></entry>

                  <entry>May be used to filter the messages dispatched
                  to your consumer.</entry>
                </row>

                <row>
                  <entry><parameter>durable</parameter></entry>

                  <entry>false</entry>

                  <entry>Turns the processor into a durable subscriber. 
                  Once a processor durably subscribes to a topic, if
                  it disconnects any messages sent will be saved and
                  delivered once the processor reconnects. This setting 
                  only affects processors attached to topics,
                  and is ignored for queue processors.</entry>
                </row>

                <row>
                  <entry><parameter>config</parameter></entry>

                  <entry></entry>

                  <entry>
                    Should contain a hash of data which will be passed
                    to your consumer's constructor,
                    <function>initialize(Hash)</function>.
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <example>
            <title>Messaging configuration in
            <filename>torquebox.yml</filename> with options
            set</title>

            <para><programlisting>application:
  ...
messaging:
  /queues/foo:
    MyFooHandler:
      filter: "cost &gt; 30"
      config:
        type: "premium"
        season: "fall"
      concurrency: 2
  /topics/bar:
    MyBarHandler:
      durable: true</programlisting></para>

            <para>Because the structure of the file is <ulink
            url="http://www.yaml.org">YAML</ulink>, proper indentation
            is required.</para>
          </example>

          <para>Actually, YAML enables the configuration to get fairly
          sophisticated, allowing you to, for example, map a single
          destination to multiple processors or re-use configuration
          options in multiple processors. You may never have a need
          for this much flexibility, but it's available if you
          do.</para>

          <example>
            <title>Advanced messaging configuration in
            <filename>torquebox.yml</filename></title>

            <para><programlisting>application:
  ...

messaging:
  /topics/simple: SimpleHandler

  /topics/popular:
    - Handler
        concurrency: 5
    - Observer: &amp;defaults
        filter: "x &gt; 18"
        config:
          x: ex
          y: why
    - Processor

/queues/students:
    VerySimpleAnalyzer:
    YouthMonitor:
      filter: "y &lt; 18"
      config:
        h: ache
        i: eye
    LookAndFeel:
      &lt;&lt;: *defaults</programlisting></para>

            <para>Here we have <code>/topics/simple</code> mapped to a
            single processor of type <code>SimpleHandler</code> using
            a YAML <emphasis>string</emphasis>,
            <code>/topics/popular</code> mapped to three processors
            (<code>Handler</code>, <code>Observer</code>,
            <code>Processor</code>) using a YAML
            <emphasis>list</emphasis>, and
            <code>/queues/students</code> mapped to three more
            processors (<code>VerySimpleAnalyzer</code>,
            <code>YouthMonitor</code>, <code>LookAndFeel</code>) using
            a YAML <emphasis>hash</emphasis> where each key in the
            hash corresponds to the processor type. This example also
            takes advantage of YAML's ability to merge hash's: the
            <code>Observer</code> and <code>LookAndFeel</code>
            processors are configured identically.</para>
          </example>

          <section>
            <title>Connecting Consumers outside of TorqueBox</title>

            <para>To support messaging outside of TorqueBox,
            i.e. outside of the JBoss Application Server (AS), two
            command-line utilities are provided: one that can deploy
            your <filename>queues.yml</filename> (or
            <filename>topics.yml</filename>) and one that can deploy
            your <filename>messaging.yml</filename> config
            file.</para>

            <para><example>
              <title>Deploying your Consumers outside of the App
              Server</title>

              <para><programlisting>$ trq-message-processor-host --deploy messaging.yml
              </programlisting></para>

              <para>Optionally, you can pass <code>-N
              your.naming.host</code> if there's not a naming server
              running locally</para>
            </example></para>

            <para>Firing up the consumers doesn't do much good without
            the actual destinations, though...</para>

            <para><example>
              <title>Deploying your Destinations outside of the App
              Server</title>

              <para><programlisting>$ trq-message-broker -s --deploy queues.yml
              </programlisting></para>

              <para>The <code>-s</code> option tells the broker to
              fire up its own naming service. Otherwise, it attempts
              to use a local one.</para>
            </example></para>
          </section>
        </section>
      </section>
    </section>

    <section id="async-tasks">
      <title>Tasks</title>

      <para>A special case of message queues is to execute some task
      asynchronously, perhaps even remotely. Rails developers often
      want to spawn a potentially long-running task in response to a
      user request, without forcing the user to wait for its
      completion. TorqueBox makes this easy.</para>

      <section id="task-classes">
        <title>Task Classes</title>

        <para>Task classes simply extend
        <classname>TorqueBox::Messaging::Task</classname> and
        implement one or more (usually long-running) methods that take
        a single object payload, a Ruby
        <classname>Hash</classname>.</para>

        <para>In Rails applications, these tasks should be placed in
        the <filename>app/tasks/</filename> directory. For non-Rails
        applications, they should be placed in <filename>tasks/</filename>.
        The tasks should be suffixed with <filename>_task.rb</filename> 
        for the file name,
        and suffixed with <classname>Task</classname> for the class
        name.</para>

        <para>Any of the task's methods can be invoked asynchronously
        by calling the task's class method,
        <function>async</function>.</para>

        <para><example>
          <title>Example task class</title>

          <para><programlisting>class EmailerTask &lt; TorqueBox::Messaging::Task
  def send_welcome(payload)
    to = "#{payload[:name]} &lt;#{payload[:address]}&gt;"
    # send welcome email to the user
  end

  def send_password_reset(payload)
    email = payload[:address]
    # send password-reset email to the user
  end
end</programlisting></para>
        </example></para>
      </section>

      <section>
        <title>Invoke a task</title>

        <para>Tasks can be invoked asynchronously from within any
        application running inside TorqueBox, e.g. your Rails
        app.</para>

        <para><example>
          <title>Spawning a task from a Rails controller</title>

          <para><programlisting>class UserController &lt; ApplicationController
  def register
    user = User.new(params[:user])
    ...
    EmailerTask.async(:send_welcome, :address =&gt; user.email, :name =&gt; user.name)
  end
  def reset_password
    ...
    EmailerTask.async(:send_password, :address =&gt; params[:email])
  end
end</programlisting>The first parameter to the <function>async(...)</function>
          class method is a symbol indicating the method to execute
          asynchronously. Optional hash pairs comprising the payload of the
          message follow.</para>
        </example></para>
      </section>

      <section id="task-invocation-options">
        <title>Task invocation options</title>
        <para>When invoking a task, you can override the default priority, time-to-live,
        and persistence options by passing an options hash to
        <function>async</function>. The available options are:</para>
  
        <table>
          <title>Task invocation options</title>
  
          <tgroup cols="3">
            <colspec align="left" />
  
            <thead>
              <row>
                <entry>Option</entry>
  
                <entry>Default</entry>
  
                <entry>Description</entry>
              </row>
            </thead>
  
            <tbody>
              <row>
                <entry><parameter>:priority</parameter></entry>
  
                <entry>:normal</entry>
  
                  <entry>higher priority messages will be delivered before lower priority
                  messages within the context of a queue. You can specify the priority as
                  an integer in the range 0..9, or as one of the following convenience
                  symbols (with the corresponding integer priorities in parentheses):
                  <itemizedlist>
                    <listitem><para><parameter>:low</parameter> (1)</para></listitem>
                    <listitem><para><parameter>:normal</parameter> (4)</para></listitem>
                    <listitem><para><parameter>:high</parameter> (7)</para></listitem>
                    <listitem><para><parameter>:critical</parameter> (9)</para></listitem>
                  </itemizedlist>
                  Higher priority messages will be processed before lower priority ones
                  for a specific message processor.</entry>
              </row>
  
              <row>
                <entry><parameter>:ttl</parameter></entry>
  
                <entry></entry>
  
                <entry>The maximum time the message will wait in a
                destination to be consumed, in milliseconds. If the
                message isn't consumed within this time it will be
                delivered to an expiry queue. By default, messages don't have a
                ttl (and therefore never expire). By default, expired messages 
                end up on the <varname>/queue/ExpiryQueue</varname> queue. If
                you want to do something special with those messages, you'll need 
                to add a processor for that queue.</entry>
              </row>
  
              <row>
                <entry><parameter>:persistent</parameter></entry>
  
                <entry>true</entry>
  
                <entry>By default, queued messages will survive across AS restarts.
                If you don't want a message to be persistent, set the persistence to
                <parameter>false</parameter>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
  
        <para>The options are passed as the third argument to <function>async</function>:</para>
        <para><example>
          <title>Passing options to <function>async</function></title>
  
            <para><programlisting>SomeTask.async(:an_important_action, {:id =&gt; 28}, :priority =&gt; :high)
SomeTask.async(:a_timeboxed_action, {:some_value =&gt; :foo}, :ttl =&gt; 5000)
</programlisting>The message options are passed as a <classname>Hash</classname> after the
            payload argument.</para>
          </example></para>
      </section>
  
      <section id="task-message-processor-options">
        <title>Task message processor options</title>
        <para>You can set options for the message processors for each task in 
        <filename>torquebox.yml</filename>. Currently, the concurrency is the 
        only available option:</para>
  
        <table>
          <title>Task message processor options</title>
  
          <tgroup cols="3">
            <colspec align="left" />
            
            <thead>
              <row>
                <entry>Option</entry>
                
                <entry>Default</entry>
                
                <entry>Description</entry>
              </row>
            </thead>
            
            <tbody>
              <row>
                <entry><parameter>concurrency</parameter></entry>
  
                <entry>1</entry>
  
                <entry>May be used to throttle the throughput of
                your processor. Processors are single-threaded, by
                default, but you can increase this value to match
                the number of concurrent messages you expect to
                receive.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
  
        <para>The options are set in the <filename>torquebox.yml</filename> by keying the
        options to the task class name:</para>
  
        <example>
          <title>Task message processor options in
              <filename>torquebox.yml</filename></title>
  
              <para><programlisting>application:
  ...
tasks:
  SomeTask:
    concurrency: 2
  SomeOtherTask:
    concurrency: 5</programlisting></para>
        </example>

      </section>
    </section>

    <section id="backgroundable">
      <title><classname>Backgroundable</classname> Methods</title>
      <para>In addition to <link linkend="task-classes">task classes</link>
      for background proccessing, TorqueBox also provides <classname>Backgroundable</classname>
      methods. <classname>Backgroundable</classname> allows you to process any
      method on any object asynchronously. You can mark a method to
      *always* execute in the background, or send a method to the
      background on an ad hoc basis.</para>

      <section>
        <title><function>always_background</function></title>
        <para><classname>Backgroundable</classname> provides the 
        <function>always_background</function> class method that allows you to flag a 
        method to always be executed in the background:</para>
      
        <example>
          <title>Having a method always execute in the background</title>
          <para><programlisting>class User &lt; ActiveRecord::Base
  always_background :send_signup_notification

  def send_signup_notification
    ...
  end
end

user = User.find(id)

# executes in the background, returning immediately
user.send_signup_notification
  </programlisting>The <function>always_background</function> method can be called before or after
          the method being backgrounded is defined, and can take multiple method symbols: 
          <function>always_background :foo, :bar</function>.</para>
        </example>

        <para>You can also call <function>always_background</function> from outside of the class
        definition if you prefer:</para>

        <example>
          <title>Alternative <function>always_background</function> usage</title>
          <para><programlisting>class User &lt; ActiveRecord::Base
  def send_signup_notification
    ...
  end
end

User.always_background(:send_signup_notification)
  </programlisting></para>
        </example>
      </section>

      <section>
        <title><function>background</function></title>      
        <para>If you have not marked an instance method with 
        <function>always_background</function>, you can background it at call time
        with the <function>background</function> instance method:</para>

        <example>
          <title>Backgrounding a method ad hoc</title>
          <para><programlisting>class User &lt; ActiveRecord::Base
  def process_avatar(image_data)
    ...
  end
end

user = User.find(id)

# executes in the background, returning immediately
user.background.process_avatar(the_image)

# executes in the foreground (this thread)
user.process_avatar(the_image)
</programlisting></para>
        </example>
      </section>

      <section>
        <title>The <classname>Backgroundable</classname> module</title>
        <para>To use <classname>Backgroundable</classname> methods in a class, you will
        need to include the <classname>TorqueBox::Messaging::Backgroundable</classname> 
        module into the class:</para>

        <example>
          <title>Including the <classname>Backgroundable</classname> module</title>
          <para><programlisting>class User
  include TorqueBox::Messaging::Backgroundable
  ...
end
          </programlisting>Including <classname>Backgroundable</classname> provides both the
          <function>always_background</function> class method and the 
          <function>background</function> instance method.</para>
        </example>
        <para>If your appplication uses Rails and you use the rails template that ships 
        with TorqueBox (<filename>$TORQUEBOX_HOME/share/rails/template.rb</filename>), you 
        should have an initializer 
        (<filename>RAILS_ROOT/config/initializers/active_record_backgroundable.rb</filename>) 
        that already includes <classname>Backgroundable</classname> 
        into <classname>ActiveRecord::Base</classname>.</para>
      </section>

      <section>
        <title>Object/argument marshaling</title>
        <para>We serialize the receiver and arguments using Marshal and include them in
        the message that gets enqueued. The message processors run in a separate ruby runtime from
        the application, which may be on a different machine if you have a cluster. The marshaling 
        works well for ActiveRecord objects and basic ruby objects. It may not work as well for 
        objects that expect a lot of plumbing in place (ActionControllers, for example).</para>
      </section>

      <section>
        <title><classname>Backgroundable</classname> method invocation options</title>
        <para>The priority, time-to-live, and persistence options that are available to
        <link linkend="task-invocation-options">available to task classes</link> are available to 
        <classname>Backgroundable</classname> methods as well:</para>

        <example>
          <title>Passing options to <classname>Backgroundable</classname> methods</title>
  
            <para><programlisting>class Widget
  always_background :productize, :priority =&gt; :low
  def productize
    ...
  end

  def monetize
    ...
  end
end

widget = Widget.new

widget.background(:ttl => 1000, :persistent => false).monetize
</programlisting>The message options are passed as a <classname>Hash</classname> as the
            last argument to <function>always_background</function>, and as the only
            argument to <function>background</function>. Options passed to 
            <function>always_background</function> affect every background invocation
            of the specified methods, while options passed to <function>background</function>
            affect only that particular invocation.</para>
          </example>
      </section>

      <section>
        <title><classname>Backgroundable</classname> message processor options</title>
        <para>The concurrency option that is 
        <link linkend="task-message-processor-options">available to task class message processors</link>
        in <filename>torquebox.yml</filename> is available to 
        <classname>Backgroundable</classname> message processors as well. Instead of a task
        class name, you specify <classname>Backgroundable</classname>:</para>

        <example>
          <title>Task message processor options in
              <filename>torquebox.yml</filename></title>
  
              <para><programlisting>application:
  ...
tasks:
  Backgroundable:
    concurrency: 2
  SomeTask:
    concurrency: 5</programlisting></para>
        </example>
        <para>By default, every application you deploy will have a queue for <classname>Backgroundable</classname>
        methods, even if you don't use it. To turn off the queue, set the <varname>concurrency</varname> to 0.</para>
      </section>

    </section>
  </section>
</chapter>
